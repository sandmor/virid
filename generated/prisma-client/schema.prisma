generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  // Prisma CLI loads .env by default. Next.js will load .env.local at runtime.
  // Ensure DATABASE_URL is available when running Prisma commands.
  url      = env("DATABASE_URL")
}

// Stores per-provider API keys overriding environment variables.
// Only include providers we integrate with directly (e.g., openai, google, openrouter, etc.)
// Id is the canonical slug for the provider ("openai", "google", "openrouter").
model Provider {
  id     String @id @db.VarChar(64)
  apiKey String @db.Text

  @@map("Provider")
}

model Tier {
  id                          String   @id @db.VarChar(32)
  modelIds                    String[]
  // Token bucket configuration (per user for this tier)
  bucketCapacity              Int // Maximum tokens that can accumulate
  bucketRefillAmount          Int // Tokens added each interval
  bucketRefillIntervalSeconds Int // Interval length in seconds

  @@map("Tier")
}

model User {
  id    String @id @db.VarChar(191) // Accept Clerk style ids (e.g. user_...) or UUIDs
  email String @db.VarChar(128)

  chats                Chat[]
  documents            Document[]
  suggestions          Suggestion[]
  archiveEntries       ArchiveEntry[]
  pinnedArchiveEntries ChatPinnedArchiveEntry[]
  rateLimit            UserRateLimit?

  @@map("User")
}

// Per-user token bucket runtime state for rate limiting
model UserRateLimit {
  userId     String   @id @db.VarChar(191)
  tokens     Int
  lastRefill DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("UserRateLimit")
}

model Chat {
  id          String   @id @default(uuid()) @db.Uuid
  createdAt   DateTime
  title       String   @db.Text
  userId      String   @db.VarChar(191)
  visibility  String   @default("private")
  lastContext Json?
  // Aggregated future-proof chat settings bucket (pinnedEntries, tool allow list, etc.)
  // Shape is managed in application code; left unvalidated at the DB level for forward compatibility.
  settings    Json?

  // Fork / lineage metadata
  parentChatId        String? @db.Uuid
  forkedFromMessageId String? @db.Uuid
  forkDepth           Int     @default(0)

  user                 User                     @relation(fields: [userId], references: [id])
  messages             Message[]
  votes                Vote[]
  streams              Stream[]
  pinnedArchiveEntries ChatPinnedArchiveEntry[]

  @@index([parentChatId])
  @@map("Chat")
}

model Message {
  id          String   @id @default(uuid()) @db.Uuid
  chatId      String   @db.Uuid
  role        String
  parts       Json
  attachments Json
  createdAt   DateTime

  chat  Chat   @relation(fields: [chatId], references: [id])
  votes Vote[]

  @@index([chatId])
  @@map("Message")
}

model Vote {
  chatId    String  @db.Uuid
  messageId String  @db.Uuid
  isUpvoted Boolean

  message Message @relation(fields: [messageId], references: [id])
  chat    Chat    @relation(fields: [chatId], references: [id])

  @@id([chatId, messageId])
  @@map("Vote")
}

model Document {
  id        String   @db.Uuid
  createdAt DateTime
  title     String   @db.Text
  content   String?
  kind      String   @default("text")
  userId    String   @db.VarChar(191)

  user        User         @relation(fields: [userId], references: [id])
  suggestions Suggestion[]

  @@id([id, createdAt])
  @@map("Document")
}

model Suggestion {
  id                String   @id @default(uuid()) @db.Uuid
  documentId        String   @db.Uuid
  documentCreatedAt DateTime
  originalText      String   @db.Text
  suggestedText     String   @db.Text
  description       String?
  isResolved        Boolean  @default(false)
  userId            String   @db.VarChar(191)
  createdAt         DateTime

  user     User     @relation(fields: [userId], references: [id])
  document Document @relation(fields: [documentId, documentCreatedAt], references: [id, createdAt])

  @@map("Suggestion")
}

model Stream {
  id        String   @id @default(uuid()) @db.Uuid
  chatId    String   @db.Uuid
  createdAt DateTime

  chat Chat @relation(fields: [chatId], references: [id])

  @@map("Stream")
}

// Archive memory system: per-user knowledge entries and their relationships.
model ArchiveEntry {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.VarChar(191)
  slug      String   @db.VarChar(128)
  entity    String   @db.Text
  tags      String[]
  body      String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  outgoingLinks ArchiveLink[]            @relation("sourceLinks")
  incomingLinks ArchiveLink[]            @relation("targetLinks")
  pinnedInChats ChatPinnedArchiveEntry[]

  @@unique([userId, slug])
  @@index([userId, slug])
  @@map("ArchiveEntry")
}

// Join table mapping pinned archive entries to chats (user scoped for ownership enforcement)
model ChatPinnedArchiveEntry {
  id             String   @id @default(uuid()) @db.Uuid
  chatId         String   @db.Uuid
  archiveEntryId String   @db.Uuid
  userId         String   @db.VarChar(191)
  pinnedAt       DateTime @default(now())

  chat         Chat         @relation(fields: [chatId], references: [id], onDelete: Cascade)
  archiveEntry ArchiveEntry @relation(fields: [archiveEntryId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, archiveEntryId])
  @@index([chatId])
  @@index([archiveEntryId])
  @@index([userId])
  @@map("ChatPinnedArchiveEntry")
}

model ArchiveLink {
  id            String   @id @default(uuid()) @db.Uuid
  sourceId      String   @db.Uuid
  targetId      String   @db.Uuid
  type          String   @db.VarChar(64)
  bidirectional Boolean  @default(false)
  createdAt     DateTime @default(now())

  source ArchiveEntry @relation("sourceLinks", fields: [sourceId], references: [id], onDelete: Cascade)
  target ArchiveEntry @relation("targetLinks", fields: [targetId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@index([targetId])
  @@index([type])
  @@map("ArchiveLink")
}
